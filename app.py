# pylint: disable=missing-module-docstring
# https://srssql.streamlit.app/
# https://srssql-develop.streamlit.app/

import logging  # logger de python
import os
from datetime import date, timedelta
import subprocess
import sys

import duckdb
import pandas as pd
import streamlit as st
from streamlit.logger import get_logger  # logger de streamlit


# ------------------------------------------------------------------------
# Streamlit specific part
# checking streamlit cloud configuration
# ------------------------------------------------------------------------
app_logger = get_logger(__name__)
app_logger.setLevel(logging.INFO)  # here can set DEBUG, ERROR, WARNING

if "data" not in os.listdir():
    app_logger.info("duckdb database set up")
    app_logger.info("List working directory content: %s", os.listdir())
    app_logger.info("Create 'data' folder, if it doesn't exist")
    os.makedirs("data", exist_ok=True)  # exist_ok useful if "if" not used

if "sql_exercises.duckdb" not in os.listdir("data"):
    app_logger.info("Create Database and tables_names")
    subprocess.run(  # pylint: disable=E0602
        [f"{sys.executable}", "SRS_SQL/init_db.py"],  # pylint: disable=E0602
        check=False,
    )


# ------------------------------------------------------------------------
# START OF MAIN PART
# ------------------------------------------------------------------------
class Exercise:
    """
    Class for the "exercise" objects
    :attributes:
    - name of the exercise
    - names of the tables used in the exercise
    - solution query of the exercise
    - solution dataframe to compare to the dataframe generated by the user query
    :methods:
    - choose_theme : selector, initiate the exercise object according to user choice and db
    - show_tables : display exercise tables
    - check_user_solution : compare user query generated df to solution df
    - show_solution : display the solution query
    """

    def __init__(self):
        self.name = ""
        self.tables_names = [""]
        self.solution_query = ""
        self.solution_df = pd.DataFrame()

    # useful functions
    def choose_theme(self):
        """
        Let the user choose the theme of the exercise he wants to revise.
        Loads :
        - exercise.name
        - exercise.tables_names
        - exercise.solution_query
        - exercise.solution_df
        :return: nothing
        """
        # global   #theme_selected, answer_query, exercise, f,
        # get existing themes from the db to the select box
        # -------------------------------------------------
        # st.write((con.execute("SELECT DISTINCT theme FROM exercises").df())["theme"])
        theme_list = (
            con.execute("SELECT DISTINCT theme FROM exercises")
            .df()["theme"]
            .unique()  # easy way to put to list
        )
        theme_selected = st.selectbox(
            "What would you like to review?",
            theme_list,
            index=None,  # Default choice is None
            placeholder="Select what you want to review",
        )
        # get available exercises in this theme sorted by last_reviewed
        # --------------------------------------------------------------
        if theme_selected:
            st.write("You selected:", theme_selected)
            theme_query = f"SELECT * FROM exercises WHERE theme = '{theme_selected}'"
        else:
            theme_query = "SELECT * FROM exercises"
        memory_df = (
            con.execute(theme_query).df().sort_values("last_reviewed", ascending=True)
        )
        st.write(memory_df)

        # Load exercises tables_names names for 1st exercise of the list
        # ---------------------------------------------------------
        self.tables_names = memory_df.iloc[0]["tables_names"]

        # load answer of the 1st exercise in the list
        # --------------------------------------------
        self.name = memory_df.iloc[0]["name"]

        # get answer_query stored in the exercise solution file
        # ------------------------------------------------------
        with open(
            f"answers/{self.name}.sql", "r", encoding="utf-8"
        ) as f:  # r for read only
            self.solution_query = f.read()

        # load solution df using answer_query
        # ------------------------------------
        self.solution_df = con.execute(self.solution_query).df()

    def show_tables(self):
        """
        Display the tables_names of the exercise chosen
        - tables_names
        :return:
        """
        try:
            for table in self.tables_names:
                # load tables_names
                st.write(f"table: {table}")
                df_table = con.execute(f'SELECT * FROM "{table}"').df()
                st.dataframe(df_table)

        except IndexError:  # no theme chosen
            st.write("")
            # st.write("No exercise selected yet, no tables_names loaded.")

    def show_expected(self):
        """
        Display the tables_names of the exercise chosen
        - solution table
        :return:
        """
        try:
            # load answer_df
            st.write("expected:")
            st.dataframe(self.solution_df)
        except IndexError:  # no theme chosen
            st.write("")
            # st.write("No exercise selected yet, no tables_names loaded.")

    def check_user_solution(self, user_query: str) -> None:
        """
        Checks that user SQL query is correct:
        1: checking the columns with exercise.solution_df
        2: checking the values with exercise.solution_df
        :param user_query: a string containing the query inserted by the user
        :return: None
        """
        try:
            # Remark : user can query any table of db without choosing a theme !
            input_df = con.execute(user_query).df()
            st.dataframe(input_df)
            # theme chosen
            try:
                # give a hint on lines difference
                nb_lines_difference = self.solution_df.shape[0] - input_df.shape[0]
                if nb_lines_difference != 0:
                    if nb_lines_difference > 0:
                        st.write(f"The solution has {nb_lines_difference} lines more.")
                    else:
                        st.write(f"The solution has {-nb_lines_difference} lines less.")

                # sort solution_df columns like input_df's to ease comparison
                try:
                    input_df = input_df[self.solution_df.columns]
                    # compare
                    try:
                        comparison_result = input_df.compare(self.solution_df)
                        # No difference found
                        if comparison_result.empty:
                            st.write("You found the right solution.")
                            st.balloons()
                        else:
                            st.write("Not yet, here are the differences :")
                            st.dataframe(comparison_result)
                    # value error
                    except ValueError as e:
                        st.write(f"{e}")
                # different columns
                except KeyError:
                    st.write("Some columns are missing or different.")
            # no theme : no solution
            except NameError:
                st.write("No theme selected yet, no solution loaded.")
        # no input_query
        except AttributeError:
            st.write("")
        # input_query : syntax error (duckdb)
        except duckdb.duckdb.ParserException as e:  # pylint: disable=I1101
            st.write("incorrect input sent, not an SQL command")
            st.write(f"{e}")
        # input_query : missing table (duckdb)
        except duckdb.duckdb.CatalogException as e:  # pylint: disable=I1101
            st.write(f"{e}")

    def show_solution(self):
        """
        displays the solution of the exercise
        :return:
        """
        try:
            st.text(self.solution_query)  # .text to keep text layout
        except NameError:  # answer_query not loaded
            st.write("")
            # st.write("No exercise selected yet, no tables_names loaded.")

    def srs_buttons(self):
        """
        Displays the 3 buttons for the Spaced Repetition System
        - one to delay to next revision to day +2
        - one to delay to next revision to day +7
        - one to delay to next revision to day +21
        - one to reset last_reviewed to good old time
        Updates the exercises database "last_reviewed" date so it's reorganised
        :return:
        """
        for n_days in [2, 7, 21]:
            if st.button(f"Review in {n_days} days"):
                next_review = date.today() + timedelta(days=n_days)
                con.execute(
                    f"UPDATE exercises SET last_reviewed = '{next_review}' "
                    + f"WHERE name = '{self.name}'"
                )
                st.rerun()
        # testing button, will be removed
        if st.button("Reset"):
            con.execute("UPDATE exercises SET last_reviewed = '1970-01-01'")
            st.rerun()


# connecting db
con = duckdb.connect(database="data/sql_exercises.duckdb", read_only=False)

# ------------------------------------------------------------------------
# DISPLAY PART
# ------------------------------------------------------------------------
# Page title
st.write(
    """
# SRS SQL 
Spaced Repetition System SQL practice
"""
)

# -----------------------------------------------------------
# Sidebar to choose the theme to revise
# -----------------------------------------------------------
exercise = Exercise()

with st.sidebar:
    exercise.choose_theme()

    # -----------------------------------------------------------
    # tabs with exercise specifics and solution
    # -----------------------------------------------------------
    tab1, tab2 = st.tabs(["Tables", "Solution"])
    with tab1:
        col1, col2 = st.columns(2)

        with col1:
            exercise.show_tables()
        with col2:
            exercise.show_expected()

    with tab2:
        exercise.show_solution()

# -----------------------------------------------------------
# Input zone
# -----------------------------------------------------------
st.header("enter your code:")
input_query = st.text_area(label="your SQL code here")  # , key="user_input")

exercise.check_user_solution(input_query)

# -----------------------------------------------------------
# Spaced Repetition System
# -----------------------------------------------------------
exercise.srs_buttons()
